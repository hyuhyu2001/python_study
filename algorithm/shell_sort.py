#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@author:     jinzj
@desc:内部排序-插入排序-希尔排序
    希尔排序是1959 年由D.L.Shell 提出来的，相对直接排序有较大的改进。希尔排序又叫缩小增量排序
基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。
操作方法：
    选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
    按增量序列个数k，对序列进行k 趟排序；
    每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。
    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
算法实现：
    希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；
    随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
    详细解释：
    我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 .....1} n为要排序数的个数。
    即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，
    每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。
    继续不断缩小增量直至为1，最后使用直接插入排序完成排序。
希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。
目前还没有人给出选取最好的增量因子序列的方法。
增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。
希尔排序方法是一个不稳定的排序方法。
希尔排序是基于插入排序的以下两点性质而提出改进方法的：
（1）插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
（2）但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
"""

def shell_sort(lists):
    '''希尔排序最关键的是选择步长
    本程序选用Knuth在1969年提出的步长序列：1 4 13 40 121 364 1093 3280 。
    后一个元素是前一个元素*3+1，非常方便选取，而且效率还不错'''
    length=len(lists)
    inc=0
    while inc<=length/3:
        inc=inc*3+1
    print(inc)
    while inc>=1:
        for i in range(inc,length):
            tmp=lists[i]
            for j in range(i,0,-inc):
                if tmp<lists[j-inc]:
                    lists[j]=lists[j-inc]
                else:
                    j+=inc
                    break
            lists[j-inc]=tmp
        inc//=3
    return lists


if __name__ == '__main__':
    lists = [5,8,6,7,9,4,2,1,3,5,6,8,9,100]
    result = shell_sort(lists)
    print(result)
